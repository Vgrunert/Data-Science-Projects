---
title: "Mietspiegel"
author: "Vincent Grunert"
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
   - \usepackage{float}
output: 
github_document:
    toc: true
    toc_depth: 2
---
\pagebreak
# Executive Summary
Ziel dieser Arbeit ist es ein Modell fuer die Schaetzung des Nettomietpreises zu erhalten. Hierzu wurde eine ausfuehrliche Datenkontrolle und -analyse durchgefuehrt. Anhand der Best Subset Methode wurde das beste auf den Daten basierende lineare Modell berechnet. Hinzufuegen von Interaktionstermen konnte zu keiner Modellverbesserung fuehren.  

Das Modell weist folgende Probleme auf: Zum einen gibt es inhomogene Varianzen. Fuer dieses Modell fuehrte der Versuch, dieses Problem zu beheben, jedoch zu einem schlechteren Ergebnis. Zum anderen konnten einige Ausreisser in den Daten identifiziert werden. Aufgrund mangelnder inhaltlicher Grundlage diese zu entfernen, werden diese im Modell behalten. 

Aus diesen Guenden wird zur Schaetzung des Nettomietpreises ein lineares Modell mit allen bereitgestellten Variablen empfohlen.

\pagebreak

```{r, include = FALSE}

library(readxl)
library(xtable)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(reshape2)
library(nlme)
library(lmtest)
library(sandwich)
library(rpart)
library(rpart.plot)
options(scipen = 1e+9)
path <- "./data.xlsx"

miete <- read_xlsx(path, sheet = 2)
names(miete) <- c(
  "Nettomiete", "Wohnflaeche", "Zimmeranzahl", "Baujahr", "Gute_Wohnanlage", "Beste_Wohnanlage", "Warmwasservers.", "Zentralheizung", "Gekacheltes_Bad", "Bes_Zusatzausst_Bad", "Gehobene_Kueche")



# Ich bin Immobilienmakler und betreibe in Wien ein Firma. Wir wollen eine genauere Analyse des Marktes für Mietwohnungen durchführen. 
# Uns interessiert, was sind die Key Treiber für den Mietpreis bei privater Wohnungsmiete in unserer Stadt. Wovon hängt die höhe der Nettomiete ab?

# Ich beauftrage Sie ein entsprechendes Untersuchungsdesign zu erstellen. 

# Univariate Analysesn
# a) Kennzahlen
#     Mittelwert, Standardabweichung, Schiefe, Minimum, 1.Quantil, Median, 3.Quantil, Maximum
#     Modus, eventuell 2., 3. etc. größte Werte
# b) Grafische Darstellung
# c) Datenkontrolle, Qualitätskontrolle
# d) Ziel: machen Sie sich ein Bild von den Objekten, die
# Sie vor sich haben.


attach(miete)


# names(miete)
# erstelle eine neue variable: alter = 2003 - bj 

is_binary <- function(x) x == 0 | x == 1
daten_kontrolle <- function(daten = miete){
  # daten kontrollieren
  # missing values?
  fehlende_werte <- any(is.na(daten))

  # keine zahl?
  keine_zahl <- any(apply(miete, 2, is.nan))

  # sind alles zahlen?
  alles_zahlen <- all(apply(miete, 2, is.numeric))

  # negarive zahlen (duerften nicht vorkommen)
  neg_werte <- any(miete < 0)

  # alle anderen variablen haben nur null und eins als definitionsbereich. dies laesst sich leicht testen
  alles_binaer <- all(apply(daten[,5:ncol(daten)], 2, function(x) all(is_binary(x))))

  # teste ob alle bedingungen erfuellt sind
  !fehlende_werte & !keine_zahl & alles_zahlen & !neg_werte & alles_binaer
}

if(!daten_kontrolle(miete)) warning("Es sind fehlerhafte Daten vorhanden.")

```
# Daten
Im Folgenden werden die Ergebnisse der Datenkontrolle, Datenaenderungen, Uni-, Bi- und Trivariate Analysen dargestellt.

## Datenkontrolle
Der Datensatz enthaelt insgesamt `r nrow(miete)` Beobachtungen von insgesamt `r ncol(miete)` verschiedenen Variablen. Im ersten Schritt wurde eine formale Datenkontrolle durchgefuehrt. Es konnten keine Fehler in den Daten festgestellt werden. Konkret wurde auf fehlende- und unmoegliche Werte, korrekte Datenformate und ob alle Werte den theoretisch Moeglichen entsprechen. Hierbei handelt es sich nicht um eine Inhaltliche Kontrolle, diese erfolgt im naechsten Abschnitt.   

## Datenaenderungen
### Baujahr
Der Datensatz enthaelt die Variable "Baujahr", fuer die folgende Aenderungen durchgefuehrt wurden 1) Fuer eine verbesserte Interpretierbarkeit wurde diese in "Alter" umcodiert. Das Alter entspricht der Differenz aus den Jahr 2003 und dem Baujahr der Wohnung. 2) Das Alter wird in 20 Jahres Bloecke zusammengefasst. Den letzten Block, "(80, 80+]" umfasst alle Wohnungen die 80- oder mehr Jahre alt sind. 

Bei der Variable gibt es zwei Auffaelligkeiten. Zum einen sind `r sum(miete$Baujahr == 1918)` Wohnungen im Jahr 1918 gebaut worden und keine danach. Dies laesst eine Zuordnung aller Wohnungen im Jahr 1918 oder frueher gebauten Wohnungen zu diesem Baujahr vermuten. Zum anderen wurden zwei Wohnungen nicht wie alle anderen einem ganzen Jahr zugeordnet sondern wurden im respektive Jahreshaelfte nummeriert (zB 14.5 Jahre). Beide Punkte koennen durch die Zusammenfassung in 20 Jahresbloecke gehandhabt werden. Weiters kann man davon ausgehen, dass Jahr zu Jahr unterschiede sich nicht massgeblich auf den Wohnungspreis auswirken sollte. In Summe wird somit eine Zusammenfassung in 20 Jahres Bloecke gerechtfertigt. 

### Wohnanlage
Der Datensatz enthaelt zwei Variablen "Gute Wohnanlage" und "Beste Wohnanlage". Da keine Wohnung in beiden Kategorien enthalten ist, fassen wir beide Variablen zusammen und bezeichnen diese als "Wohnungsanlage". Diese besteht aus drei Kategorien: "Normale Wohnanlage", "Gute Wohnanlage" und "Beste Wohnanlage". "Normale Wohnanlage" sind all jene, die nicht in den anderen beiden Kategorien enthalten sind. 

### Umbenennungen
Der Datensatz enthaelt die Variablen: "Warmwasserversorgung enthalten", "Zentralheizung vorhanden" und "Gekacheltes Badezimmer". Diese drei Variablen sind untypisch codiert da "Nein" jeweils den Wert "1" und "Ja" dem Wert "0" zugeordnet wird. Ueblicherweise erfolgt die Codierung genau umgekehrt, so wie dies auch bei den anderen Binaeren Variablen (Variablen die nur zwei Werte annehmen) in dem Datensatz erfolgte. Um eine unmissverstaendliche Interpretation der Variablen zu gewaehrleisten werden die drei genannten umbenannt in "Ohne Warmwasserversorgung enthalten", "Ohne Zentralheizung vorhanden" und "Ohne Gekacheltes Badezimmer". Somit koennen wir den Wert "1" wieder als "Ja" interpretieren und die "0" als "Nein". 


## Univariate Analysen
```{r, include = FALSE, cache = TRUE}
# problem baujahr
# 1) halbjahreszahlen -> kein problem weil die daten ohnehin zusammengefasst werden
# 2) Viele Beobachtungen im Jahr 1918 (macht offensichtlich keine Sinn) wie 1) wir fassen die Jahre in 20 Jahreskategorien zusammen

nm <- miete["Nettomiete"]
nm <- pull(nm) 
wfl <- miete["Wohnflaeche"]
wfl <- pull(wfl) 
rooms <- miete["Zimmeranzahl"]
rooms <- pull(rooms) 
bj <- miete["Baujahr"]
bj <- pull(bj) 
alter <- 2003 - bj
wohngut <- miete["Gute_Wohnanlage"]
wohngut <- pull(wohngut)
wohnbest <- miete["Beste_Wohnanlage"]
wohnbest <- pull(wohnbest)

# folgende drei variablen sind ungewohnlich kodiert in dem sinne dass 0 fuer ja und 1 fuer nein steht
# wir schaffen somit drei neue variablen die wir als negierte originale, dh warmwasserversorgung -> keine warmwasserversorgung etc benennen
ww0 <- miete["Warmwasservers."]
ww0 <- pull(ww0)
ohne_ww0 <- ww0

zh0 <- miete["Zentralheizung"]
zh0 <- pull(zh0)
ohne_zh0 <- zh0

badkach0 <- miete["Gekacheltes_Bad"]
badkach0 <- pull(badkach0)
ohne_badkach0 <- badkach0

# durchschn_wfl <- wfl / rooms

# wir schaffen eine neue variable Wohnqualitaet die aus drei Gruppen besteht,
# "Normal" fuer alle wohnungen die nicht in wohngut oder wohnbest sind
# "Gut" fuer alle wohnungen die in "wohngut sind"
# "Beste" fuer die wohnungen die in wohnbest sind aber wir muessen auf ueberschneidungen zwischen wohngut und wohnbest aufpassen
which(wohngut == 1 & wohnbest == 1)
# gibt keine 

# also wenn eine wohnung nicht in wohngut oder wohnbest dann sagen wir sie ist normal
# which(wohngut == 0 & wohnbest == 0)
wohnnorm <- ifelse(wohngut == 0 & wohnbest == 0, 1, 0)
wohnanl <- ifelse(wohnnorm == 1, 1, ifelse(wohngut == 1, 2, 3))
wohnanl <- factor(wohnanl, labels = c("Normal", "Gut", "Beste"))

badextra <- miete["Bes_Zusatzausst_Bad"]
badextra <- pull(badextra)
kueche <- miete["Gehobene_Kueche"]
kueche <- pull(kueche)       

# speicher alten miete datensatz
miete_alt <- miete

# schaffe neuen mit transformierten daten
miete <- data.frame(
  Nettomiete = nm,
  Wohnflaeche = wfl, 
  Zimmeranzahl = rooms,
  Alter_Gruppiert = cut(2003-miete_alt$Baujahr, breaks = c(0, 20, 40, 60, 80, Inf), labels = c("(0,20]","(20,40]",  "(40,60]",  "(60,80]", "(80,80+]")), 
  Wohnanlage = wohnanl,
  Ohne_Warmwasservers = ohne_ww0,
  Ohne_Zentralheizung = ohne_zh0,
  Ohne_Gekacheltes_Bad = ohne_badkach0,
  Extra_Badausst = badextra,
  Gehobene_Kueche = kueche
)
```

### Nettomietpreise
```{r, echo = FALSE, figures-side, fig.show="hold", out.width="33%", cache = TRUE}
nm <- miete$Nettomiete
nm_stats <- c(round(min(nm)-1), round(quantile(nm, 0.25)), round(mean(nm)), round(quantile(nm, 0.75)), round(quantile(nm, 0.95)), round(max(nm)))

cat_nm <- cut(nm, nm_stats, dig.lab = 5)

# anzahl an beobachtungen in den jeweiligen kategorien
table_nm_cat <- table(cat_nm)

# speicher im df fuer die grafische aufbearbeitung
df_nm <- data.frame(table_nm_cat)

# cumsums
cumsum_cat_nm <- cumsum(table_nm_cat)
names(cumsum_cat_nm) <- paste("Nmiete <=", nm_stats[-1])
df_cumsum_nm <- data.frame(Cat = names(cumsum_cat_nm), Freq = cumsum_cat_nm)


# boxplot: einige ausreisser nach oben
ggplot(miete) + geom_boxplot(aes(y = nm)) + labs(title = "Nettomiete", x=" ", y="Nettomiete") 

# histogram
# ggplot(miete) + geom_histogram(aes(x = nm), bins = 10) + labs(title = "Nettomiete", x="Nettomiete", y="Anzahl")
ggplot(df_nm, aes(x=cat_nm, y = Freq)) + geom_bar(stat = "identity", fill = c("grey35", "red", "red", "grey35", "grey35")) + geom_text(aes(label = Freq), vjust = -1 ) + labs(title="Mietpreiskategorien",
        x =" ", y = "Haeufigkeit")+ ylim(c(0, 320)) 

# kummulierte haeufigkeiten
df_cumsum_nm %>% arrange(Freq) %>% mutate(name = factor(Cat, levels=names(cumsum_cat_nm))) %>% ggplot(aes(x=name, y = Freq, label = scales::percent(Freq/1000))) + geom_bar(stat = "identity", fill = c("grey35", "red", "grey35", "grey35", "grey35")) + geom_text(vjust = -1) + labs(title="Mietpreiskategorien Kummuliert", x =" ", y = "Haeufigkeit")+ ylim(c(0, 1050)) 
```

Grafik 1 (links) laesst eine symmetrische Verteilung der Nettomietpreise mit einigen Ausreissern nach oben (Schwarze Punkte) erkennen. Grafik 2 (Mitte) gibt die Anzahl der Wohnungen in den entsprechenden Nettomietenintervallen wider: `r sum(nm >392 & nm <= 699)/10`% der Wohnungen hat einen Mietpreis zwischen 392-699 und jeweils ein Viertel liegt darunter und darueber. Die Intervallslaenge nimmt zu den Raendern hin deutlich waechst. Das letzte Intervall, den teuersten 50 Wohnungen (`r 50/10`%), entspricht ungefaehr der Zusammenlegung der ersten drei Intervalle (0-699). Grafik 3 (rechts) die kumulierten Haeufigkeiten der Nettomietpreise wieder. Man kann erkennen dass 55.4% der Wohnungen einen Nettomietpreis kleiner oder gleich 575 haben. 


### Wohnflaeche
Die durchschnittliche Wohnflaeche liegt bei: `r round(mean(wfl))` Quadratmeter (qm). Grafik 1 (links) deutet auf eine symmetrische Verteilung der Daten mit einigen Ausreissern nach oben. Grafik 2 (Mitte) gibt die absoluten Haeufigkeiten wieder. Die Anzahl der Wohnungen wird mit steigender Flaeche immer kleiner. Weiters nimmt die Streuung zu den Raendern hin immer mehr zu. `r (267 + 215)/10`% der Wohnungen sind auf das Intervall von 55-85 qm konzentriert (in rot markierte Balken). Mehr wie die Haelfte (54%) der Wohnungen haben eine Flaeche von 71 qm oder weniger (Grafik 3, rechts).   

```{r, echo = FALSE, fig.show="hold", out.width="33%", cache = TRUE, warning=FALSE, message = FALSE}
wfl <- miete$Wohnflaeche
wfl_stats <- c(round(min(wfl))-1, round(quantile(wfl, 0.25)), round(mean(wfl)), round(quantile(wfl, 0.75)), round(quantile(wfl, 0.95)), round(max(wfl)))

cat_wfl <- cut(wfl, wfl_stats)

# haeufigkeiten der kategorien
table_wfl_cat <- table(cat_wfl)

# cusum 
cumsum_cat_wfl <- cumsum(table_wfl_cat)
names(cumsum_cat_wfl) <- paste("Wflaeche <=", wfl_stats[-1])
df_cumsum_wfl <- data.frame(Cat = names(cumsum_cat_wfl), Freq = cumsum_cat_wfl)

# speicher in einem data frame fuer die visualisierung
df_wfl <- data.frame(table_wfl_cat)

# einige ausreisser nach oben
ggplot(miete) + geom_boxplot(aes(y = wfl)) + labs(title="Wohnflaeche", x ="", y = "Haeufigkeit")
# boxplot(wf)

# histogram
# ggplot(miete) + geom_histogram(aes(x = wfl)) 

# histogram der kategorien 
ggplot(df_wfl, aes(x=cat_wfl, y = Freq)) + geom_bar(stat = "identity", fill = c("grey35", "red", "red", "grey35", "grey35")) + geom_text(aes(label = Freq), vjust = -1 ) + labs(title="Wohnflaeche",
        x ="", y = "Haeufigkeit") + ylim(c(0, 320))

# kummulierte haeufigkeiten
df_cumsum_wfl %>% arrange(Freq) %>% mutate(name = factor(Cat, levels=names(cumsum_cat_wfl))) %>% ggplot(aes(x=name, y = Freq, label = scales::percent(Freq/1000))) + geom_bar(stat = "identity", fill = c("grey35", "red", "grey35", "grey35", "grey35")) + geom_text(vjust = -1) + labs(title="Wohnflaeche Kummuliert", x ="", y = "Haeufigkeit") + ylim(c(0, 1050))
 
``` 

\pagebreak


### Zimmer
`r (327 + 385)/10`% der Wohnungen hat zwei oder drei Zimmer. Zu den Raendern hin nimmt die Haeufigkeit stark ab (Grafik 1, links). Deutlich vor allem die Anzahl der Wohnungen mit fuenf oder sechs Wohnungen macht `r 31/10` % der gesamten Wohnungen aus. 82.4% der Wohnungen haben drei oder weniger Zimmer (Grafik 2, rechts).  

```{r, echo = FALSE, fig.show="hold", out.width="50%", cache = TRUE, warning=FALSE, message = FALSE}
rooms <- miete$Zimmeranzahl

# haeufigkeiten der kategorien
table_rooms <- table(rooms)

# cusum 
cumsum_rooms <- cumsum(table_rooms)
names(cumsum_rooms) <- paste("Zimmer <=", names(table_rooms))
df_cumsum_rooms <- data.frame(Cat = names(cumsum_rooms), Freq = cumsum_rooms)

# speicher in einem data frame fuer die visualisierung
df_rooms <- data.frame(table_rooms)

# histogram der kategorien 
ggplot(df_rooms, aes(x=rooms, y = Freq)) + geom_bar(stat = "identity", fill = c("grey35", "red", "red","grey35", "grey35", "grey35")) + geom_text(aes(label = Freq), vjust = -1 ) + labs(title="Zimmeranzahl",
        x ="", y = "Haeufigkeit") + ylim(c(0, 420))

# kummulierte haeufigkeiten
df_cumsum_rooms %>% arrange(Freq) %>% mutate(name = factor(Cat, levels=names(cumsum_rooms))) %>% ggplot(aes(x=name, y = Freq, label = scales::percent(Freq/1000))) + geom_bar(stat = "identity",fill = c("grey35", "grey35", "red","grey35", "grey35", "grey35")) + geom_text(vjust = -1) + labs(title="Zimmeranzahl Kummuliert", x ="", y = "Haeufigkeit") + ylim(c(0, 1050))
```

### Alter
Im Folgenden wird die Notation "80+" fuer all jene Wohnungen, die aelter wie 80 Jahre sind, eingefuehrt. Es gab vor allem in der Zeit zwischen dem ersten und zweitem Weltkrieg einen deutlichen Einbruch (40) an Wohnungsbauten. Diesem folgte ein starker Anstieg in den Nachkriegsjahren bis in die 80 Jahre hinein, wo sich der Wohnungsbau stabilisierte. 76.1% aller Wohnungen sind in der Zeit nach dem Zweiten Weltkrieg gebaut worden. 

```{r, echo = FALSE, fig.show="hold", out.width="50%", cache = TRUE, warning=FALSE, message = FALSE}
alter <- miete$Alter_Gruppiert
table_alter <- table(alter)
names(table_alter) <- c(names(table(alter))[1:4], "(80,80+]")

# cusum 
cumsum_alter <- cumsum(table_alter)
names(cumsum_alter) <- paste("Alter <=", c(20, 40, 60, 80, "80+"))
df_cumsum_alter <- data.frame(Cat = names(cumsum_alter), Freq = cumsum_alter)

# speicher in einem data frame fuer die visualisierung
df_alter <- data.frame(table_alter)

# histogram der kategorien 
ggplot(df_alter, aes(x= Var1, y = Freq)) + geom_bar(stat = "identity", fill = c("grey35", "grey35", "grey35","grey35", "red")) + geom_text(aes(label = Freq), vjust = -1,size = 2.5 ) + labs(title="Alter", x ="", y = "Haeufigkeit") + ylim(c(0, 350)) 

# kummulierte haeufigkeiten
df_cumsum_alter %>% arrange(Freq) %>% mutate(name = factor(Cat, levels=names(cumsum_alter))) %>% ggplot(aes(x=name, y = Freq, label = scales::percent(Freq/1000))) + geom_bar(stat = "identity", fill = c("grey35", "grey35", "red","grey35", "grey35")) + geom_text(vjust = -1) + labs(title="Alter Kummuliert", x ="", y = "Haeufigkeit") + ylim(c(0, 1050))
```

\pagebreak

### Kategorische Variablen
Der Datensatz enthaelt zusaetzlich kategorische Variablen, deren Haeufigkeiten in den folgenden Grafiken dargestellt werden. Fuer alle folgenden Variablen lassen sich grosse Unterschiede in den Haeufigkeiten feststellen.  

```{r, echo = FALSE, fig.show="hold", out.width="33%", cache = TRUE, warning=FALSE, message = FALSE}
table_wq <- table(miete$Wohnanlage)
table_ohne_ww <- table(miete$Ohne_Warmwasservers)
table_ohne_zh <- table(miete$Ohne_Zentralheizung)
table_ohne_badkach <- table(miete$Ohne_Gekacheltes_Bad)
table_badextra <- table(miete$Extra_Badausst)
table_kueche <- table(miete$Gehobene_Kueche)

ggplot(data.frame(table_wq), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_wq, vjust = -1) + labs(title="Wohnanlage", x ="", y = "Haeufigkeit") + ylim(c(0,610))

ggplot(data.frame(table_ohne_ww), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_ohne_ww, vjust = -1) + labs(title="Ohne Warmwasserversorgung", x ="", y = "Haeufigkeit")+ scale_x_discrete(labels = c("Nein", "Ja")) + ylim(c(0,1000))

ggplot(data.frame(table_ohne_zh), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_ohne_zh, vjust = -1) + labs(title="Ohne Zentralheizung", x =" ", y = "Haeufigkeit") + scale_x_discrete(labels = c("Nein", "Ja")) + ylim(c(0,950))

ggplot(data.frame(table_ohne_badkach), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_ohne_badkach, vjust = -1) + labs(title="Gekacheltes Badezimmer", x ="", y = "Haeufigkeit") + scale_x_discrete(labels = c("Nein", "Ja")) + ylim(c(0,850))

ggplot(data.frame(table_badextra), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_badextra, vjust = -1) + labs(title="Besondere Zusatzausstattung", x ="", y = "Haeufigkeit") + scale_x_discrete(labels = c("Nein", "Ja")) + ylim(c(0,920))

ggplot(data.frame(table_kueche), aes(x = Var1, y = Freq)) + geom_bar(stat = "identity") + geom_text(label = table_kueche, vjust = -1) + labs(title="Gehobene Kueche", x ="", y = "Haeufigkeit") + scale_x_discrete(labels = c("Nein", "Ja")) + ylim(c(0, 950))

```

\pagebreak
## Bivariate Analysen
Die unteren Grafik geben die Korrelationen der Variablen wieder. Die linke Grafik enthaelt alle und die rechte Grafik nur die signifikanten Korrelationen. Wie koennen beobachten: 1) Nettomiete ist mit fast allen anderen Variablen signifikant korreliert. 2) Gehobene Kueche ist mit keiner anderen Variablen signifikant korreliert. 3) Wohnflaeche und Zimmeranzahl haben die staerkste- und Nettomiete und Wohnflaeche sind am zweitstaerkste positive Korrelation. 

```{r, echo = FALSE, fig.show="hold", out.width = "45%", fig.align = "center", cache = TRUE, warning=FALSE, message = FALSE}
t_cor <- function(x, n) x * sqrt(n-2) / sqrt(1 - x^2)
t_test <- function(x, alpha = 0.05) {
        if(1-pt(abs(x),999) < alpha / 2){
			return(TRUE)
        } else {
			return(FALSE)
		}
}

cor_miete <- cor(cbind(miete$Nettomiete, miete$Wohnflaeche, miete$Zimmeranzahl, as.numeric(miete$Alter_Gruppiert), 
                  as.numeric(miete$Wohnanlage), miete$Ohne_Warmwasservers, miete$Ohne_Zentralheizung, miete$Ohne_Gekacheltes_Bad, miete$Extra_Badausst, miete$Gehobene_Kueche))

cor_cp <- cor_miete
cor_cp[row(cor_cp) < col(cor_cp)] <- NA         
colnames(cor_cp) <- names(miete)
rownames(cor_cp) <- names(miete)
diag(cor_cp) <- 1

# Werte <- as.numeric(cor_miete)
Werte <- melt(cor_cp, na.rm = TRUE)
Werte$value <- round(Werte$value, 1) 

ggplot(Werte, aes(Var1, Var2, fill = value)) + geom_tile(colour = "white") + labs(title="Korrelationsmatrix Gesamt", x ="", y = "") + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab",name="Pearson\nCorrelation") + scale_x_discrete(guide = guide_axis(angle = 45)) + geom_text(aes(Var1, Var2, label = value), color = "black", size = 4) + theme(legend.position = "none")

# signifikant
cor_matr_t_werte <- apply(cor_miete, 2, t_cor, n = nrow(miete))
diag(cor_matr_t_werte) <- 0
res <- matrix(0, ncol = ncol(cor_miete), nrow = nrow(cor_miete))

for(i in 1:(nrow(cor_matr_t_werte)-1)){
	for(j in 1:nrow(cor_matr_t_werte)){
		if(t_test(cor_matr_t_werte[i,j], alpha = 0.01)){
			res[i,j] <- cor_miete[i,j]
		}
	}
}

res[row(res) < col(res)] <- NA         
colnames(res) <- names(miete)
rownames(res) <- names(miete)
diag(res) <- 1

# Werte <- as.numeric(cor_miete)
Werte <- melt(res, na.rm = TRUE)
Werte$value <- round(Werte$value, 1) 

ggplot(Werte, aes(Var1, Var2, fill = value)) + geom_tile(colour = "white") + labs(title="Korrelationsmatrix", x ="", y = "") + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab",name="Pearson\nCorrelation") + scale_x_discrete(guide = guide_axis(angle = 45)) + geom_text(aes(Var1, Var2, label = value), color = "black", size = 4) + theme(legend.position = "none")

```


Im Folgenden wird der Zusammenhang zwischen der Nettomiete und selektierten Variablen dargestellt. Mit steigender Wohnflaeche, steigender Zimmeranzahl steigt die Nettomiete. Hier laesst sich jeweils ein linearer Zusammenhang mit steigender Streuung noch oben beobachten. Zwischen Alter und Nettomiete koennen wir einen nicht linearen Zusammenhang beobachten. Konkret steigt die Nettomiete zu den Juengsten (0 bis 20 Jahre) und den Aeltesten (80+). 

```{r, echo = FALSE, fig.show="hold", out.width="33%", cache = TRUE, warning=FALSE, message = FALSE}
ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete)) + geom_point() + geom_smooth(method = "lm") + labs(title="Nettomiete / Wohnflaeche", x ="Wohnflaeche", y = "Nettomiete")

ggplot(miete, aes(x = as.factor(Zimmeranzahl), y = Nettomiete)) + geom_boxplot() + geom_smooth(method = "lm", se=TRUE, aes(group=1)) + labs(title="Nettomiete / Zimmeranzahl", x ="Zimmeranzahl", y = "Nettomiete")

ggplot(miete, aes(x = Alter_Gruppiert, y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Alter", x ="Alter", y = "Nettomiete") + geom_smooth(method = "loess", se=TRUE, aes(group=1))+ scale_x_discrete(labels = names(table_alter))

```

Im Folgenden wird fuer die restlichen Variablen die Nettomiete auf die entsprechenden Auspraegungen dargestellt. In allen Faellen kann man deutliche Unterschiede zwischen den Kategorien feststellen. 

```{r, echo = FALSE, fig.show="hold", out.width="33%", cache = TRUE, warning=FALSE, message = FALSE}
ggplot(miete, aes(x = Wohnanlage, y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Wohnanlage", x ="", y = "Nettomiete")

# warmwasser
ggplot(miete, aes(x = as.factor(Ohne_Warmwasservers), y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Ohne Warmwasserversorgung", x ="", y = "Nettomiete") + scale_x_discrete(labels = c("Nein", "Ja"))

# zentralheizung
ggplot(miete, aes(x = as.factor(Ohne_Zentralheizung), y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Ohne Zentralheizung", x ="", y = "Nettomiete") + scale_x_discrete(labels = c("Nein", "Ja"))

# gekacheltes badezimmer
ggplot(miete, aes(x = as.factor(Ohne_Gekacheltes_Bad), y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Ohne Gekacheltes Badezimmer", x ="", y = "Nettomiete") + scale_x_discrete(labels = c("Nein", "Ja"))
#summary(aov(nm ~ badkach0))
#summary(lm(nm ~ badkach0))

# badezimmer extraausstattung
ggplot(miete, aes(x = as.factor(badextra), y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Badezimmer mit Extraausstattung", x ="", y = "Preis") + scale_x_discrete(labels = c("Nein", "Ja"))
#summary(aov(nm ~ badextra))
#summary(lm(nm ~ badextra))

# gehobene kueche
ggplot(miete, aes(x = as.factor(kueche), y = Nettomiete)) + geom_boxplot() + labs(title="Nettomiete / Mit Gehobener Kueche", x ="", y = "Preis") + scale_x_discrete(labels = c("Nein", "Ja"))
#summary(aov(nm ~ kueche))
#summary(lm(nm ~ kueche))
```


## Trivariate Analysen
Im Folgenden werden noch Zusammenhaenge zwischen dem Nettomietpreis und jeweils zwei anderen Variablen dargestellt. Diese Darstellung ermoeglicht eine differenzierte Betrachtung von Effekten die nur zwischen zwei Variablen gleichzeitig aufkommen. Auffaellige unterschiede konnten vor allem fuer die Variablen Wohnflaeche, Alter_Gruppiert und Wohnanlage festgestellt werden.

### Wohnflaeche + 
Wir vermuten dass die Wohnflaeche der Massgebliche Treiber fuer den Mietpreis darstellt und betrachten somit saemtliche Modelle wo die Nettomiete durch die Wohnflaeche und noch einer weiteren Variablen dargestellt werden. Die folgende Grafiken geben jeweils die Regressionsgerade fuer die Wohnflaeche in Abhaengigkeit der zweiten Variable wieder. Interessiert sind wir insbesondere an unterschiedlichen Steigungen da diese als Indikator fuer Interaktionseffekte zwischen zwei Variablen dienen. Die folgenden Grafiken geben die entsprechenden Resultate wieder. Wir beobachten, dass die Nettiete bei Wohnflaeche und:

* Wohnungen mit sechs Zimmern (a) 
* Wohnungen bis zu 20 Jahren (b) 
* in bester Lage (c)
* mit Zentralheizung und (d)
* mit Gehobener Kueche (e)

sich deutlich von anderen unterscheidet. 



```{r, echo = FALSE, fig.show="hold", out.width="33%", cache = TRUE, warning=FALSE, message = FALSE}

ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete, color= as.factor(Zimmeranzahl))) + geom_smooth(method = "lm", alpha = 0.1 ) + labs(title="(a) Nettomiete / Wohnflaeche und Zimmeranzahl", x ="Wohnflaeche", y = "Nettomiete", color = "Zimmeranzahl") + theme(legend.position = "bottom")

ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete, color = Alter_Gruppiert)) + geom_smooth(method = "lm", alpha = 0.1) + labs(title="(b) Nettomiete / Wohnflaeche und Alter_Gruppiert", x ="Wohnflaeche", y = "Nettomiete", color = "Alter_Gruppiert") + theme(legend.position = "bottom")

ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete, color = Wohnanlage)) +  geom_smooth(method = "lm") + labs(title="(c) Nettomiete / Wohnflaeche und Wohnanlage", x ="Wohnflaeche", y = "Nettomiete", color = "Wohnanlage") + theme(legend.position = "bottom")

ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete, color = as.factor(Ohne_Zentralheizung))) + geom_smooth(method = "lm") + labs(title="(d) Nettomiete / Wohnflaeche und Ohne Zentralheizung", x ="Wohnflaeche", y = "Nettomiete", color = "Ohne Zentralheizung") + theme(legend.position = "bottom")

ggplot(miete, aes(x = Wohnflaeche, y = Nettomiete, color = as.factor(Gehobene_Kueche))) + geom_smooth(method = "lm") + labs(title="(e) Nettomiete / Wohnflaeche und Gehobene Kueche", x ="Wohnflaeche", y = "Nettomiete", color = "Gehobene Kueche") + theme(legend.position = "bottom")

```

\pagebreak

### Alter + 

Die folgenden beiden Grafiken geben den Nettomietpreis fuer die unterschiedlichen Altersklassen in Abhaengigkeit von der Zimmeranzahl (a) und Gehobene Kueche (b) wieder. Fuer die Zimmeranzahl koennen wir einen deutlichen unterschied zwischen sechs Zimmer Wohnungen bei bis zu 20 Jahre alten Wohnungen und anderen sechs Zimmer Wohnungen. Bei Wohnungen mit gehobener Kueche faellt auf, dass im Vergleich zu Wohnungen ohne gehobener Kueche der Nettomietpreis ueber die Alterskategorieen konstant verlaeuft. Hier wirkt sich also das Alter weniger stark auf den Mietpreis aus. 

```{r, echo = FALSE, fig.show="hold", out.width="50%", cache = TRUE, warning=FALSE, message = FALSE}
ggplot(miete, aes(y = Nettomiete, x = Alter_Gruppiert, fill = as.factor(Zimmeranzahl))) + geom_boxplot() + labs(title="(a) Nettomiete / Alter_Gruppiert und 
Zimmeranzahl", x ="Alter", y = "Nettomiete", fill = "Zimmeranzahl") + theme(legend.position = "bottom")

ggplot(miete, aes(y = Nettomiete, x = Alter_Gruppiert, fill = as.factor(Gehobene_Kueche))) + geom_boxplot() + labs(title="(b) Nettomiete / Alter_Gruppiert und 
Gehobene Kueche", x ="Alter", y = "Nettomiete", fill = "Gehobene Kueche") + theme(legend.position = "bottom")

```

### Wohnanlage

Die folgende Grafik gibt die Nettomiete je Wohnanlage und Extra Badausstattung wieder. Wie koennen erkennen, dass vor allem in der besten Wohnanlage ein deutlich hoeherer Mietepreis fuer Wohnungen mit Extra Badausstattung vorhanden ist wie fuer andere. 

```{r, echo = FALSE, fig.show="hold", fig.align = 'center',out.width="50%", cache = TRUE, warning=FALSE, message = FALSE}
ggplot(miete, aes(y = Nettomiete, x = Wohnanlage, fill = as.factor(Extra_Badausst))) + geom_boxplot() + labs(title="Nettomiete / Wohnanlage und 
Extra Badausstattung", x ="Wohnanlage", y = "Nettomiete", fill = "Extra_Badausst") + theme(legend.position = "bottom")
```

\pagebreak

# Modellselektion

Bevor das eigentliche Modell geschaetzt wird, soll ein Entscheidungsbaum uns weitere Auskuenfte ueber moegliche Zusammenhaenge geben. 


## Entscheidungsbaum

Entscheidungsbaeume sind ein flexibeles Mittel, um klassenspezifische Durchschnitte zu berechnen. Entscheidungsbaeume koennen aber zur Variablenselektion verwendet werden, da sie eine Hierarchie der wichtigsten Variablen erzeugen. Folgende Grafik gibt den Entscheidungsbaum fuer diesen Datensatz wieder. 

```{r, echo = FALSE, fig.show="hold", fig.align = 'center', cache = TRUE}
tree <- rpart(Nettomiete ~ ., data = miete, method = "anova", control=list(cp = 0.005))
rpart.plot(tree)
```

Die Grafik ist wie folgt zu verstehen: Auf oberster Ebene wird der Mittelwert der Nettomiete `r round(mean(miete$Nettomiete))` wiedergegeben. Dieser Enthaelt alle, d.h. 100% der Beobachtungen. Die groesste Varianzreduktion kann duch eine Aufteilung der Wohnflaeche in Wohnungen die kleiner oder groesser wie 80 Quadratmeter (qm) sind erreicht werden. Der durchschnittliche Nettomietpreis fuer Wohnungen die kleiner wie 80 qm sind ist 476 und fuer Wohnungen die groesser wie 80 qm sind 780. Weitere Unterteilungen folgen diesem Muster.  

Wohnflaeche ist auf den ersten beiden Ebenen die Entscheidungsvariable. Fuer Wohnungen unter 80 qm koennen wir beobachten, dass im Folgenden die Variablen "Ohne Zentralheizung" und das gruppierte Alter zu weiteren Entscheidungsvariablen werden. Fuer Wohnungen groesser gleich 80 qm folgt in dritter Ebene das gruppierte Alter als Entscheidungsvariable, wobei in Folgenden Ebenen Wohnflaeche wieder als Entscheidungsvariable Auftaucht.  

Zusammenfassend halten wir fest, dass die Wohnflaeche die dominanteste Variable in der Erklaerung des Nettomietpreises ist. Fuer kleiner Wohnungen ist dann die Variable Ohne_Zentralheizung als zweitdominanteste Variable. Fuer groesser Wohnungen sind ebenfalls die Wohnflaeche und das Alter die dominanten Faktoren die den Nettomietpreis erklaeren. 

\pagebreak

## Variablenselektion und Modifikation
Die hohe Korrelation zwischen Wohnflaeche und Zimmeranzahl (`r round(cor_miete[2,3], 1)`) fuehrt zu einem Schaetzproblem wenn beide Variablen zur Modellierung verwendet werden. Konkret fuehrt eine Inklusion beider Variablen zu einem positiven Zusammenhang zwischen Wohnflaeche und Nettomietpreis einen negativen Zusammenhang zwischen Zimmeranzahl und Nettomietpreis. Da wir bereits einen stark positiven Zusammenhang zwischen Zimmeranzahl und Nettomietpreis beobachten konnten macht ein negativer Zusammenhang inhaltlich keinen Sinn. Aufgrund der besseren Interpretierbarkeit, sowie numerischer Eigenschaften, der Wohnflaeche wird diese stellvertretend fuer beide Variablen fuer die Schaetzung verwendet. Ein weiterer Grund liegt in der Eindeutigkeit der Wohnflaeche. Eine kleine Wohnung kann auch mehrere Zimmer haben und eine grosse Wohnung kann nur wenige Zimmer haben und ist somit nicht unbedingt eindeutig.  

## Methode

Geschaetzt wird ein multivariates lineares Regressionsmodell. Die Modellselektion erfolgt in einem Dreischrittverfahren. Im ersten Schritt wird aufgrund der geringen Anzahl an Beobachtungen und Variablen die Best Subset Methode zu Modellschaetzung verwendet. Im zweiten Schritt werden wir das Modell aus der Best Subset Methode um die gemachten Interaktionen ergaenzen. Wenn notwendig wird dann das Modell mit Interaktionen dann noch "manuell" verfeinert.  


### Best Subset
Das Best Subset Verfahren schaetzt jedes moegliche Modell aus den vorhandenen Variablen ohne Interaktionen oder Transformationen und selektiert aus allen das beste. Konkret werden zuerst alle Modelle mit einer erklaerenden Variablen, dann alle mit zwei usw, bis letztendlich das Modell mit allen erklaerenden Variablen gerechnet wird. In jeder Stufe wird das beste Modell bestimmt. Zuletzt wird dann aus den besten Modellen nochmals das Beste selektiert.   

```{r include = FALSE, cache = TRUE}

# excludiere zimmeranzahl
miete_neu <- miete[,-3]

n_var <- ncol(miete_neu)-1
# save results
res <- list()


for(i in 1:n_var){

    # combn returns a matrix with all possoble permutations of a given object
    # this will serve to select all possible models for each "level" i
    select <- t(combn(1:i, m = i)+1)

    # number of models for each level
    n  <- nrow(select)

    # init temp variable for later use
    temp  <- Inf

    # for each permutation
    for(j in 1:n){
        # calculate the model
        # model  <- glm(as.formula(paste("fraud_reported ~", paste(rownames(sig)[select[j,]], collapse = "+"))),family = "binomial", data = fraud)
        model  <- lm(formula(paste(names(miete_neu)[1], " ~ ", paste(names(miete_neu)[select[j,]], collapse = "+"))),data = miete_neu)

        # select the model with the smallest SSR at each level
        if(sum(residuals(model)^2) < temp){

            # new smalles value
            temp  <- sum(residuals(model)^2)

            # store model
            res[[i]]  <- list(
                Variables = paste(names(miete_neu)[select[j,]]),  
                SSR = sum(residuals(model)^2), 
                Mod = model,
                NumVariables = i)
        }
    }    
}

res

mallows_cp <- function(model){
    n <- length(model$residuals)
    p <- length(model$coefficients)
    trng_rss <- mean(model$residuals^2)
    sigma_hat <- sum(model$residuals^2) / (n-p)
    korrekturfaktor <- (2/n) * sigma_hat
    return( trng_rss + korrekturfaktor )  
}

# compare AIC, BIC and Mallow's Cp
modell_selection  <- matrix(0, ncol = 3, nrow = length(res))
colnames(modell_selection)  <- c("AIC", "BIC", "Mallow's Cp")

# vergleiche resultate
i <- 1
for(elem in res){
    modell_selection[i, 1]  <- AIC(elem$Mod) 
    modell_selection[i, 2]  <- BIC(elem$Mod)
    modell_selection[i, 3]  <- mallows_cp(elem$Mod) 
    i <- i + 1
}

# get rowindex of smellest value in each column
best_model_mod_selection  <- apply(modell_selection, 2, function(x){which(x == min(x))})
best_model_mod_selection

# beste subset modell
best_model <- res[[best_model_mod_selection[1]]]$Mod
sum_best_model <- summary(best_model)

```

Das beste Modell ist jenes mit allen `r best_model_mod_selection[1]` erklaerenden Variablen. Fuer dieses Modell erhalten wir einen angepassten $R^2$ Wert von `r round(sum_best_model$adj.r.squared,2)`.

### Best Subset Schaetzergebnis

Das Modell wird durch einen Breusch-Pagan-Test auf ungleiche Varianz (Heteroskedastizitaet) geprueft. Das Ergebnis ist hochsignifikant was als Indikator fuer ungleiche Varianzen verstanden wird. Diese fuehren zu Verzerrungen in der Varianz des Schaetzers. Dieses Problem kann durch eine heteroskedastizitaet konsistente Schaetzung, die im Folgenden fuer alle weiteren Schaetzungen ebenfalls durchgefuehrt wird, behoben werden. Die Ergebnisse werden in der folgenden Tabelle dargestellt: 
```{r, echo = FALSE, fig.pos = 'hold', results = 'asis', message = FALSE}
    options(xtable.comment = FALSE)
    mod_1 <- lm(Nettomiete ~ ., data = miete_neu)
    sum_table <- round(coeftest(best_model, vcovHC(best_model, "HC0"))[1:13,], 5)
	print(xtable(sum_table, type = 'latex'))	
  #sum_table
```

### Interaktionen

Da Zimmeranzahl aus der weiteren Analyse bereits ausgeschlossen wurde, bleiben aus der Trivariaten Analyse folgende Interaktionseffekte uebrig:

* Wohnflaeche: Alter_Gruppiert-, Wohnlage-, Ohne Zentralheizung und Gehobene Kueche
* Alter: Gehobene Kueche
* Wohnanlage und Extra Badausstattung 

Im Folgenden werden wird das Best Subset Modell um diese Interaktionen erweitert. Die nachstehende Tabelle gibt die signifikanten Variablen wieder. Wir beobachten dass ausser den beiden Interaktionen zwischen Wohnflaeche und Alter_Grupperiert sowie Wohnflaeche und Wohnanlage keine weiteren Interaktionenen signifikant sind. Allerdings sind nun einige Variablen nicht mehr statistisch signifikant.  Die folgende Tabelle gibt die Resultate der Schaetzung wieder:

```{r, echo = FALSE, fig.pos = 'hold', results = 'asis', message = FALSE}
    options(xtable.comment = FALSE)
    sum_lminter <- summary(lsinter <-lm(Nettomiete ~  Wohnflaeche * Wohnanlage + Wohnflaeche *Alter_Gruppiert +  Wohnflaeche *Ohne_Zentralheizung + Wohnflaeche * Gehobene_Kueche +  Alter_Gruppiert * Gehobene_Kueche + Wohnanlage *Extra_Badausst + Ohne_Warmwasservers + Ohne_Gekacheltes_Bad , data = miete))
    
    sig_model_het <- coeftest(lsinter, vcovHC(lsinter, "HC0"))
    sig_model_het_sig <- which(sig_model_het[, 4] < 0.05)
    sig_model <- round(sig_model_het[sig_model_het_sig, ], digits = 3)
    print(xtable(sig_model, type = 'latex'))	
    #sum_table
```
Das  Modell hat einen adjustierten $R^2$ von `r round(sum_lminter$adj.r.squared, 2)`.

### Anpassung

Im Vergleich beider Modelle erkennen wir, dass das Modell ohne Interaktionen nicht alle Effekte beruecksichtigt und das Modell mit allen relevanten Interaktionen zu unsinnigen Resultaten fuehrt. Wegen der Best Subset Methode wissen wir, dass die individuellen Variablen alle statistisch signifikant sind und sollten somit auch im Modell enthalten sein. Bezueglich der Interaktionen werden wir uns auf jene beschraenkten die im vorherigen Modell als Signifikant identifiziert wurden. Die folgende Tabelle gibt die Werte wieder:   

```{r, echo = FALSE, fig.pos = 'hold', results = 'asis', message = FALSE}
    options(xtable.comment = FALSE)
    sum_lminter_sig <- summary(lsinter_sig <-lm(Nettomiete ~  Wohnflaeche *Alter_Gruppiert +  Alter_Gruppiert * Gehobene_Kueche + Ohne_Zentralheizung + Extra_Badausst + Ohne_Warmwasservers + Ohne_Gekacheltes_Bad , data = miete))

    sum_lminter_sig_het <- coeftest(lsinter_sig, vcovHC(lsinter_sig, "HC0"))
    sum_lminter_sig_het_sig <- which(sum_lminter_sig_het[, 4] < 0.05)
    sum_lminter_sig_het <- round(sum_lminter_sig_het[sum_lminter_sig_het_sig, ], digits = 3)
    print(xtable(sum_lminter_sig_het, type = 'latex'))	
    #sum_table
```

Bis auf die Variable Extra Badausstattung sind alle Variablen im Modell enthalten sowie die beiden Interaktionsterme aus Wohnflaeche und Alter_Gruppiert sowie Alter_Gruppiert und Gehobene Kueche. In diesem Modell erhalten wir eine adjustierten $R^2$ von `r round(sum_lminter_sig$adj.r.squared, 2)`.  

## Modell Selektion

Im Folgenden soll aus den drei Modellen eines anhand von gaengigen Modellselektionskriterien ausgewaehlt werden. Als Modellselektionskriterien werden der adjustierte $R^2$, das Akaike Informations Kriterium (AIC) sowie das Bayesianische Informations Kriterium (BIC). Fuer den adjustierten $R^2$ gilt je hoeher desto besser und fuer die anderen beiden je kleiner desto besser. Wir bevorzugen ein Modell einem anderen, wenn es in mindestens zwei Kriterien besser ist wie das andere. Die folgende Tabelle gibt die Ergebnisse der Kriterien wieder.

```{r, echo = FALSE, fig.pos = 'hold', results = 'asis', message = FALSE}
    options(xtable.comment = FALSE)
    Rsq <- c(sum_best_model$adj.r.squared, sum_lminter$adj.r.squared, sum_lminter_sig$adj.r.squared)
    AIC_mod <- c(AIC(best_model), AIC(lsinter), AIC(lsinter_sig))
    BIC_mod <- c(BIC(best_model), BIC(lsinter), BIC(lsinter_sig))
    mod_comp <- cbind(AdjRsq = Rsq, AIC = AIC_mod, BIC = BIC_mod)
    rownames(mod_comp) <- c("Keine Interakt.", "Interakt.", "SigInterakt.")
    print(xtable(mod_comp, type = 'latex'))	
    #sum_table
```

Die erste Zeile gibt die Ergebnisse fuer das Modell aus der Best Subset Methode, also ohne Interaktionen wieder. In der zweiten Zeile die Ergebnisse fuer das Modell mit den aus der Trivariaten Analyse betrachteten Interaktionen und in der letzten Zeile das Modell mit den signifikanten Interaktionen. Wir beobachten, dass das Modell mit signifikanten Interaktionen von beiden anderen Modellen dominiert wird. Wir koennen somit dieses Modell ausschliessen. Das Modell mit Interaktionen macht aus bereits genannten gruenden ebenfalls fuer die Modellierung keinen Sinn, da hier praktisch keine Variablen statistisch signifikant sind. Daher waehlen wir das Best Subset Modell. 


## Interpretation
Eine Wohnung hat einen Grundpreis von `r round(sum_table[1,1])`. Mit jedem Quadratmeter Wohnflaeche steigt der Mietpreis um `r round(sum_table[2,1])`. Eine Wohnung die zwischen 20 und 40 Jahren alt ist, hat einen um  `r -round(sum_table[3,1])` geringeren Mietpreis wie eine, die bis 20 Jahre alt ist. Die Interpretation fuer die weiteren Variablen folgt analog.  

\pagebreak

# Modell Analyse

## Homogene Varianzen
Schaetzt man ein lineares Modell mit ungleichen Varianzen in den Fehlertermen, dann ist zwar der Schaetzer im noch erwartungstreu, aber es gibt einen anderen mit geringerer Varianz. Somit testen wir im folgenden, ob in diesem Modell die Fehler ungleiche Varianzen aufweisen. Wenn ja, werden wir das selektierte Modell mit einem gewichteten linearem Regressionsmodell vergleichen. Letzters sollte theoretisch zu einer Varianzreduzierung fuehren.

Informell kann man die Varianzhomogenitaet testen indem die Modellprognose gegen die Residuen geplottet werden. Sind die Fehler konstant um eine Gerade ohne erkennbares Muster gestreut, gehen wir von konstanten Varianzen aus. In der linken Grafik sind die Ergebnisse fuer das normale Modell in der rechten fuer das gewichtete.  


```{r, echo = FALSE, fig.show="hold", out.width="50%", cache = TRUE, warning=FALSE, message = FALSE}
test_lin <- data.frame(Residuen = best_model$residuals, Fitted = best_model$fitted.values)
ggplot(test_lin, aes(x = Fitted, y = Residuen)) + geom_point() + labs(title="Residuen vs Prognose", x ="Prognose", y = "Residuen")
wt <- 1 / lm(abs(best_model$residuals) ~ best_model$fitted.values)$fitted.values^2
wls <- lm(Nettomiete ~  Wohnflaeche  +  Wohnanlage + Alter_Gruppiert + Ohne_Zentralheizung + Gehobene_Kueche + Extra_Badausst + Ohne_Warmwasservers + Ohne_Gekacheltes_Bad , data = miete, weights = wt)
ggplot(data.frame(x = wls$fitted.values, y = wls$residuals), aes(x=x, y=y)) + geom_point() + labs(title="Residuen vs Prognose Gewichtet", x ="Prognose", y = "Residuen")

```

Wir erkennen keinen markanten Unterschied. Vergleichen wir die Durchschnitte der quadrierten Residuen aus dem normalen Modell `r round(mean(best_model$residuals^2))` und dem gewichteten `r round(mean(wls$residuals^2))` erkennen wir, dass durch die Gewichtung sogar eine verschlechterung erreicht wurde. Wir bleiben somit beim urspruenglichen Modell.   

## Ausreisser
Das Modell weist einige statistische Ausreisser auf. Grafik (a) und (b) vergleicht die Residualplots der Modell mit (a) und ohne (b) Ausreisser. Wir erkennen, dass in (b) die Residuen kreisfoermig um die Null auf der y-Achse und ungefaehr den Mittelwert `r round(mean(miete$Nettomietpreis))` angeordnet sind. Grafik (c) vergleicht die Modellparameter der Modelle mit und ohne Ausreisser. Am staerksten wirken sich die Ausreisser auf die Variablen "Ohne Warmwasserversorgung" und "Beste Wohnanlage" aus. Dennoch gibt es keine offensichtliche Rechtfertigung, um die Ausreisser zu entfernen.    

```{r, echo = FALSE, fig.show="hold", out.width = "33%", message = FALSE}
cdist <- cooks.distance(best_model)
ausreisser <- unique(which(cdist > 4 * mean(cdist)))
best_mod_kein_ausreisser <- lm(Nettomiete ~  ., data = miete[-ausreisser,-3])

test_best_mod_kein_ausreisser <- data.frame(Residuen = best_mod_kein_ausreisser$residuals, Fitted = best_mod_kein_ausreisser$fitted.values)

ggplot(test_lin, aes(x = Fitted, y = Residuen)) + geom_point() + labs(title="(a) Residualplot", x ="Prognose", y = "Residuen")

ggplot(test_best_mod_kein_ausreisser, aes(x = Fitted, y = Residuen)) + geom_point() + labs(title="(b) Residualplot ohne Ausreisser", x ="Prognose", y = "Residuen")

ausreisser_vgl <- data.frame(Ohne_Ausreisser = round(best_mod_kein_ausreisser$coefficients,2), Mit_Ausreisser = round(best_model$coefficients,2))
ausr <- melt(cbind(X = rownames(ausreisser_vgl), ausreisser_vgl))

ggplot(ausr, aes(x = X, y= value, fill = variable)) + geom_bar(stat = 'identity', position = "dodge") +
  scale_x_discrete(guide = guide_axis(angle = 45)) + labs(title="(c) Modellvergleich mit und ohne Ausreisser", x ="Variable", y = "Wert")

```

# Conclusio
Basierend auf der Datenanalyse und der Best Subset Methode wurden verschiedene lineare Modelle mit unterschiedlicher Komplexitaet geschaetzt. Ein Entscheidungsbaum hat uns zusaetzliche Informationen ueber die hierarchische Struktur der Variablen gegeben. Hieraus konnten wir deutlich entnehmen, dass Wohnflaeche die dominanteste Variable zur Erklaerung des Nettomietpreises ist. 

Anhand der Best Subset Methode wurde bewertet, welches lineare Modell ohne Interaktionen oder weitere Variablentransformationen das beste ist. Aus diesem Verfahren wurde ein Modell mit allen zur Verfuegung stehenden erklaerenden Variablen gewaehlt. Dieses Modell wurde im naechsten Schritt um einige aus der Trivariaten Analyse stammenden Interaktionen ergaenzt. Dieses Modell hat einen hoeheren Erklaerungsgehalt, ist aber fuer die Anwendung unbrauchbar, da nur ganz wenige Variablen statistisch signifikant sind. Aus diesem Grund wurde noch ein Zusaetzliches Modell mit nur den aus dem vorherigem Modell statistisch signifikanten Interaktionen als Zusatz zum Best Subset Modell gerechnet. Dieses Modell ist allerdings in seiner Prognoseguete schlechter als das Best Subset Modell. Aus diesen Gruenden wurde das Best Subset Modell als finales Modell gewaehlt.

Im letzten Schritt wurde das Modell auf Verletztung der Varianzhomogenitaet sowie auf den Einfluss von Ausreissern getestet. Das Modell weist ungleiche Varianzen in den Fehlern auf. Dieses Phaenomen wirkt sich zwar nicht auf die Koeffizienten selber, sondern auf deren Varianz, aus. In Konsequenz gibt es theoretisch einen anderen Schaetzer mit geringerer Varianz. Diesen zu finden sollte durch ein gewichtetes lineares Modell erreicht werden. In diesem Modell bekommen Beobachtungen mit hoeherer Varianz eine geringere Gewichtung und tragen somit weniger zum Ergebnis bei. Allerdings fuehrt dieses Modell zu einer hoeheren Residuenvarianz womit auch dieses Verfahren verworfen wird. Nach dem Cook's Distance Kriterium wurden Ausreisser im Modell identifiziert. Im Folgenden wurde das Best Subset Modell einmal mit und einmal ohne Ausreisser gescheatzt und die Ergebnisse miteinander verglichen. Hier kamen keine besonders auffaelligen Aenderungen im Modell zutage. Wesentlicher ist allerdings, dass es keine offensichtliche Gruende gibt, Ausreisser zu entfernen. Aus diesem Grund wurde auch hier zugunsten des Modells mit Ausreissern entschieden. 

Gegen anderweitige Transformationen von Variablen wie zB Berechnung von Quadratmeterpreisen wurde aufgrund von Anwendungsgruenden entgegenentschieden. Dieses Modell, so wie es ist, kann auf jede neue Beobachtung der Form des Datensatzes direkt zur schaetzung des Nettomietpreises verwendet werden. 

Basierend auf allen gemachten Analysen wird sich zugunsten eines linearen Regressionsmodell mit allen vorhandenen Variablen, exklusive der Zimmeranzahl, ohne Interaktionen zur Erklaerung des Nettomietpreises entschieden. 













